{"version":3,"file":"TextArea.af35e63e.js","sources":["../../../../../../../../node_modules/.pnpm/carbon-icons-svelte@12.3.0/node_modules/carbon-icons-svelte/lib/MagicWandFilled.svelte","../../../../../../../../node_modules/.pnpm/ai@2.1.31_react@18.2.0_solid-js@1.9.2_svelte@4.1.2_vue@3.5.11_typescript@5.1.6_/node_modules/ai/svelte/dist/index.mjs","../../../../../../src/lib/components/AI/AIButton/CustomPromptBtn.svelte","../../../../../../src/lib/components/Form/TextArea.svelte"],"sourcesContent":["<script>\n  export let size = 16;\n\n  export let title = undefined;\n\n  $: labelled = $$props[\"aria-label\"] || $$props[\"aria-labelledby\"] || title;\n  $: attributes = {\n    \"aria-hidden\": labelled ? undefined : true,\n    role: labelled ? \"img\" : undefined,\n    focusable: Number($$props[\"tabindex\"]) === 0 ? true : undefined\n  };\n</script>\n\n<svg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  viewBox=\"0 0 32 32\"\n  fill=\"currentColor\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  width={size}\n  height={size}\n  {...attributes}\n  {...$$restProps}>\n  {#if title}<title>{title}</title>{/if}\n  <path d=\"M29.4141,24,12,6.5859a2.0476,2.0476,0,0,0-2.8281,0l-2.586,2.586a2.0021,2.0021,0,0,0,0,2.8281L23.999,29.4141a2.0024,2.0024,0,0,0,2.8281,0l2.587-2.5865a1.9993,1.9993,0,0,0,0-2.8281ZM8,10.5859,10.5859,8l5,5-2.5866,2.5869-5-5Z\"></path><path d=\"M2.586 14.586H5.414V17.414H2.586z\" transform=\"rotate(-45 4 16)\"></path><path d=\"M14.586 2.586H17.414V5.414H14.586z\" transform=\"rotate(-45 16 4)\"></path><path d=\"M2.586 2.586H5.414V5.414H2.586z\" transform=\"rotate(-45 4 4)\"></path>\n</svg>","// svelte/use-chat.ts\nimport { get, writable } from \"svelte/store\";\n\n// ../../node_modules/.pnpm/swrev@4.0.0/node_modules/swrev/dist/swrev.mjs\nvar P = Object.defineProperty;\nvar F = (r, e, t) => e in r ? P(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;\nvar h = (r, e, t) => (F(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nvar I = class {\n  constructor() {\n    h(this, \"listeners\", /* @__PURE__ */ new Map());\n  }\n  /**\n   * Subscribes a given listener.\n   */\n  subscribe(e, t) {\n    this.listeners.has(e) || this.listeners.set(e, []), !this.listeners.get(e).includes(t) && this.listeners.get(e).push(t);\n  }\n  /**\n   * Unsubscribes the given listener.\n   */\n  unsubscribe(e, t) {\n    this.listeners.has(e) && this.listeners.get(e).includes(t) && (this.listeners.get(e).splice(this.listeners.get(e).indexOf(t), 1), this.listeners.get(e).length === 0 && this.listeners.delete(e));\n  }\n  /**\n   * Emits an event to all active listeners.\n   */\n  emit(e, t) {\n    this.listeners.has(e) && this.listeners.get(e).forEach((s) => s(t));\n  }\n};\nvar L = {\n  broadcast: false\n};\nvar S = {\n  broadcast: false\n};\nvar O = class {\n  /**\n   * Creates the cache item given the data and expiration at.\n   */\n  constructor({ data: e, expiresAt: t = null }) {\n    h(this, \"data\");\n    h(this, \"expiresAt\");\n    this.data = e, this.expiresAt = t;\n  }\n  /**\n   * Determines if the current cache item is still being resolved.\n   * This returns true if data is a promise, or false if type `D`.\n   */\n  isResolving() {\n    return this.data instanceof Promise;\n  }\n  /**\n   * Determines if the given cache item has expired.\n   */\n  hasExpired() {\n    return this.expiresAt === null || this.expiresAt < /* @__PURE__ */ new Date();\n  }\n  /**\n   * Set the expiration time of the given cache item relative to now.\n   */\n  expiresIn(e) {\n    return this.expiresAt = /* @__PURE__ */ new Date(), this.expiresAt.setMilliseconds(this.expiresAt.getMilliseconds() + e), this;\n  }\n};\nvar q = class {\n  constructor() {\n    h(this, \"elements\", /* @__PURE__ */ new Map());\n    h(this, \"event\", new I());\n  }\n  /**\n   * Resolves the promise and replaces the Promise to the resolved data.\n   * It also broadcasts the value change if needed or deletes the key if\n   * the value resolves to undefined or null.\n   */\n  resolve(e, t) {\n    Promise.resolve(t.data).then((s) => {\n      if (s == null)\n        return this.remove(e);\n      t.data = s, this.broadcast(e, s);\n    });\n  }\n  /**\n   * Gets an element from the cache.\n   *\n   * It is assumed the item always exist when\n   * you get it. Use the has method to check\n   * for the existence of it.\n   */\n  get(e) {\n    return this.elements.get(e);\n  }\n  /**\n   * Sets an element to the cache.\n   */\n  set(e, t) {\n    this.elements.set(e, t), this.resolve(e, t);\n  }\n  /**\n   * Removes an key-value pair from the cache.\n   */\n  remove(e, t) {\n    const { broadcast: s } = { ...L, ...t };\n    s && this.broadcast(e, void 0), this.elements.delete(e);\n  }\n  /**\n   * Removes all the key-value pairs from the cache.\n   */\n  clear(e) {\n    const { broadcast: t } = { ...S, ...e };\n    if (t)\n      for (const s of this.elements.keys())\n        this.broadcast(s, void 0);\n    this.elements.clear();\n  }\n  /**\n   * Determines if the given key exists\n   * in the cache.\n   */\n  has(e) {\n    return this.elements.has(e);\n  }\n  /**\n   * Subscribes the callback to the given key.\n   */\n  subscribe(e, t) {\n    this.event.subscribe(e, t);\n  }\n  /**\n   * Unsubscribes to the given key events.\n   */\n  unsubscribe(e, t) {\n    this.event.unsubscribe(e, t);\n  }\n  /**\n   * Broadcasts a value change  on all subscribed instances.\n   */\n  broadcast(e, t) {\n    this.event.emit(e, t);\n  }\n};\nvar x = {\n  cache: new q(),\n  errors: new I(),\n  fetcher: async (r) => {\n    const e = await fetch(r);\n    if (!e.ok)\n      throw Error(\"Not a 2XX response.\");\n    return e.json();\n  },\n  fallbackData: void 0,\n  loadInitialCache: true,\n  revalidateOnStart: true,\n  dedupingInterval: 2e3,\n  revalidateOnFocus: true,\n  focusThrottleInterval: 5e3,\n  revalidateOnReconnect: true,\n  reconnectWhen: (r, { enabled: e }) => e && typeof window < \"u\" ? (window.addEventListener(\"online\", r), () => window.removeEventListener(\"online\", r)) : () => {\n  },\n  focusWhen: (r, { enabled: e, throttleInterval: t }) => {\n    if (e && typeof window < \"u\") {\n      let s = null;\n      const i = () => {\n        const a = Date.now();\n        (s === null || a - s > t) && (s = a, r());\n      };\n      return window.addEventListener(\"focus\", i), () => window.removeEventListener(\"focus\", i);\n    }\n    return () => {\n    };\n  },\n  revalidateFunction: void 0\n};\nvar E = {\n  ...x,\n  force: false\n};\nvar T = {\n  revalidate: true,\n  revalidateOptions: { ...E },\n  revalidateFunction: void 0\n};\nvar X = {\n  broadcast: false\n};\nvar H = class {\n  /**\n   * Creates a new instance of SWR.\n   */\n  constructor(e) {\n    h(this, \"options\");\n    this.options = { ...x, ...e };\n  }\n  /**\n   * Gets the cache of the SWR.\n   */\n  get cache() {\n    return this.options.cache;\n  }\n  /**\n   * Gets the cache of the SWR.\n   */\n  get errors() {\n    return this.options.errors;\n  }\n  /**\n   * Requests the data using the provided fetcher.\n   */\n  async requestData(e, t) {\n    return await Promise.resolve(t(e)).catch((s) => {\n      throw this.errors.emit(e, s), s;\n    });\n  }\n  /**\n   * Resolves the given to a SWRKey or undefined.\n   */\n  resolveKey(e) {\n    if (typeof e == \"function\")\n      try {\n        return e();\n      } catch (e2) {\n        return;\n      }\n    return e;\n  }\n  /**\n   * Clear the specified keys from the cache. If no keys\n   * are specified, it clears all the cache keys.\n   */\n  clear(e, t) {\n    const s = { ...X, ...t };\n    if (e == null)\n      return this.cache.clear(s);\n    if (!Array.isArray(e))\n      return this.cache.remove(e, s);\n    for (const i of e)\n      this.cache.remove(i, s);\n  }\n  /**\n   * Revalidates the key and mutates the cache if needed.\n   */\n  async revalidate(e, t) {\n    if (!e)\n      throw new Error(\"[Revalidate] Key issue: ${key}\");\n    const { fetcher: s, dedupingInterval: i } = this.options, { force: a, fetcher: o, dedupingInterval: n } = {\n      ...E,\n      fetcher: s,\n      dedupingInterval: i,\n      ...t\n    };\n    if (a || !this.cache.has(e) || this.cache.has(e) && this.cache.get(e).hasExpired()) {\n      const c2 = this.requestData(e, o), l = c2.catch(() => {\n      });\n      return this.cache.set(e, new O({ data: l }).expiresIn(n)), await c2;\n    }\n    return this.getWait(e);\n  }\n  /**\n   * Mutates the data of a given key with a new value.\n   * This is used to replace the cache contents of the\n   * given key manually.\n   */\n  async mutate(e, t, s) {\n    var _a;\n    if (!e)\n      throw new Error(\"[Mutate] Key issue: ${key}\");\n    const {\n      revalidate: i,\n      revalidateOptions: a,\n      revalidateFunction: o\n    } = {\n      ...T,\n      ...s\n    };\n    let n;\n    if (typeof t == \"function\") {\n      let c2;\n      if (this.cache.has(e)) {\n        const l = this.cache.get(e);\n        l.isResolving() || (c2 = l.data);\n      }\n      n = t(c2);\n    } else\n      n = t;\n    return this.cache.set(e, new O({ data: n })), i ? await ((_a = o == null ? void 0 : o(e, a)) != null ? _a : this.revalidate(e, a)) : n;\n  }\n  /**\n   * Gets the data of the given key. Keep in mind\n   * this data will be stale and revalidate in the background\n   * unless specified otherwise.\n   */\n  subscribeData(e, t) {\n    if (e) {\n      const s = (i) => t(i);\n      return this.cache.subscribe(e, s), () => this.cache.unsubscribe(e, s);\n    }\n    return () => {\n    };\n  }\n  /**\n   * Subscribes to errors on the given key.\n   */\n  subscribeErrors(e, t) {\n    if (e) {\n      const s = (i) => t(i);\n      return this.errors.subscribe(e, s), () => this.errors.unsubscribe(e, s);\n    }\n    return () => {\n    };\n  }\n  /**\n   * Gets the current cached data of the given key.\n   * This does not trigger any revalidation nor mutation\n   * of the data.\n   * - If the data has never been validated\n   * (there is no cache) it will return undefined.\n   * - If the item is pending to resolve (there is a request\n   * pending to resolve) it will return undefined.\n   */\n  get(e) {\n    if (e && this.cache.has(e)) {\n      const t = this.cache.get(e);\n      if (!t.isResolving())\n        return t.data;\n    }\n  }\n  /**\n   * Gets an element from the cache. The difference\n   * with the get is that this method returns a promise\n   * that will resolve the the value. If there's no item\n   * in the cache, it will wait for it before resolving.\n   */\n  getWait(e) {\n    return new Promise((t, s) => {\n      const i = this.subscribeData(e, (n) => {\n        if (i(), n !== void 0)\n          return t(n);\n      }), a = this.subscribeErrors(e, (n) => {\n        if (a(), n !== void 0)\n          return s(n);\n      }), o = this.get(e);\n      if (o !== void 0)\n        return t(o);\n    });\n  }\n  /**\n   * Use a SWR value given the key and\n   * subscribe to future changes.\n   */\n  subscribe(e, t, s, i) {\n    const {\n      fetcher: a,\n      fallbackData: o,\n      loadInitialCache: n,\n      revalidateOnStart: c2,\n      dedupingInterval: l,\n      revalidateOnFocus: A2,\n      focusThrottleInterval: C,\n      revalidateOnReconnect: R,\n      reconnectWhen: W2,\n      focusWhen: D2,\n      revalidateFunction: d\n    } = {\n      // Current instance options\n      // (includes default options)\n      ...this.options,\n      // Current call options.\n      ...i\n    }, K2 = (m) => {\n      var _a;\n      return (_a = d == null ? void 0 : d(this.resolveKey(e), m)) != null ? _a : this.revalidate(this.resolveKey(e), m);\n    }, f = () => K2({ fetcher: a, dedupingInterval: l }), u = n ? this.get(this.resolveKey(e)) : o != null ? o : void 0, g = c2 ? f() : Promise.resolve(void 0), M = u ? Promise.resolve(u) : g;\n    u && (t == null || t(u));\n    const v2 = t ? this.subscribeData(this.resolveKey(e), t) : void 0, b = s ? this.subscribeErrors(this.resolveKey(e), s) : void 0, p2 = D2(f, {\n      throttleInterval: C,\n      enabled: A2\n    }), w2 = W2(f, {\n      enabled: R\n    });\n    return { unsubscribe: () => {\n      v2 == null || v2(), b == null || b(), p2 == null || p2(), w2 == null || w2();\n    }, dataPromise: M, revalidatePromise: g };\n  }\n};\n\n// ../../node_modules/.pnpm/sswr@2.0.0_svelte@4.0.0/node_modules/sswr/dist/sswr.mjs\nimport { beforeUpdate as w, onDestroy as E2 } from \"svelte\";\nfunction p() {\n}\nfunction D(t) {\n  return t();\n}\nfunction q2(t) {\n  t.forEach(D);\n}\nfunction x2(t) {\n  return typeof t == \"function\";\n}\nfunction K(t, e) {\n  return t != t ? e == e : t !== e || t && typeof t == \"object\" || typeof t == \"function\";\n}\nfunction z(t, ...e) {\n  if (t == null) {\n    for (const r of e)\n      r(void 0);\n    return p;\n  }\n  const n = t.subscribe(...e);\n  return n.unsubscribe ? () => n.unsubscribe() : n;\n}\nvar v = [];\nfunction A(t, e) {\n  return {\n    subscribe: y(t, e).subscribe\n  };\n}\nfunction y(t, e = p) {\n  let n;\n  const r = /* @__PURE__ */ new Set();\n  function i(u) {\n    if (K(t, u) && (t = u, n)) {\n      const f = !v.length;\n      for (const s of r)\n        s[1](), v.push(s, t);\n      if (f) {\n        for (let s = 0; s < v.length; s += 2)\n          v[s][0](v[s + 1]);\n        v.length = 0;\n      }\n    }\n  }\n  function a(u) {\n    i(u(t));\n  }\n  function d(u, f = p) {\n    const s = [u, f];\n    return r.add(s), r.size === 1 && (n = e(i, a) || p), u(t), () => {\n      r.delete(s), r.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: a, subscribe: d };\n}\nfunction S2(t, e, n) {\n  const r = !Array.isArray(t), i = r ? [t] : t;\n  if (!i.every(Boolean))\n    throw new Error(\"derived() expects stores as input, got a falsy value\");\n  const a = e.length < 2;\n  return A(n, (d, u) => {\n    let f = false;\n    const s = [];\n    let h2 = 0, o = p;\n    const l = () => {\n      if (h2)\n        return;\n      o();\n      const b = e(r ? s[0] : s, d, u);\n      a ? d(b) : o = x2(b) ? b : p;\n    }, g = i.map(\n      (b, m) => z(\n        b,\n        (R) => {\n          s[m] = R, h2 &= ~(1 << m), f && l();\n        },\n        () => {\n          h2 |= 1 << m;\n        }\n      )\n    );\n    return f = true, l(), function() {\n      q2(g), o(), f = false;\n    };\n  });\n}\nvar O2 = class extends H {\n  /**\n   * Svelte specific use of SWR.\n   */\n  useSWR(e, n) {\n    let r;\n    const i = y(void 0, () => () => r == null ? void 0 : r()), a = y(void 0, () => () => r == null ? void 0 : r());\n    w(() => {\n      const o = (g) => {\n        a.set(void 0), i.set(g);\n      }, l = (g) => a.set(g);\n      r || (r = this.subscribe(e, o, l, {\n        loadInitialCache: true,\n        ...n\n      }).unsubscribe);\n    }), E2(() => r == null ? void 0 : r());\n    const d = (o, l) => this.mutate(this.resolveKey(e), o, {\n      revalidateOptions: n,\n      ...l\n    }), u = (o) => this.revalidate(this.resolveKey(e), { ...n, ...o }), f = (o) => this.clear(this.resolveKey(e), o), s = S2([i, a], ([o, l]) => o === void 0 && l === void 0), h2 = S2([i, a], ([o, l]) => o !== void 0 && l === void 0);\n    return { data: i, error: a, mutate: d, revalidate: u, clear: f, isLoading: s, isValid: h2 };\n  }\n};\nvar W = (t) => new O2(t);\nvar c = W();\nvar F2 = (t, e) => c.useSWR(t, e);\n\n// shared/utils.ts\nimport { customAlphabet } from \"nanoid/non-secure\";\nvar nanoid = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\nfunction createChunkDecoder() {\n  const decoder = new TextDecoder();\n  return function(chunk) {\n    if (!chunk)\n      return \"\";\n    return decoder.decode(chunk, { stream: true });\n  };\n}\n\n// svelte/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, extraMetadata, previousMessages, abortControllerRef, onFinish, onResponse, sendExtraMessageFields) => {\n  var _a, _b, _c, _d;\n  mutate(chatRequest.messages);\n  const res = await fetch(api, {\n    method: \"POST\",\n    body: JSON.stringify({\n      messages: sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(\n        ({ role, content, name, function_call }) => ({\n          role,\n          content,\n          ...name !== void 0 && { name },\n          ...function_call !== void 0 && {\n            function_call\n          }\n        })\n      ),\n      ...extraMetadata.body,\n      ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n      ...chatRequest.functions !== void 0 && {\n        functions: chatRequest.functions\n      },\n      ...chatRequest.function_call !== void 0 && {\n        function_call: chatRequest.function_call\n      }\n    }),\n    credentials: extraMetadata.credentials,\n    headers: {\n      ...extraMetadata.headers,\n      ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n    },\n    ...abortControllerRef !== null && {\n      signal: abortControllerRef.signal\n    }\n  }).catch((err) => {\n    mutate(previousMessages);\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(res);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!res.ok) {\n    mutate(previousMessages);\n    throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n  }\n  if (!res.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  let streamedResponse = \"\";\n  const createdAt = /* @__PURE__ */ new Date();\n  const replyId = nanoid();\n  const reader = res.body.getReader();\n  const decode = createChunkDecoder();\n  let responseMessage = {\n    id: replyId,\n    createdAt,\n    content: \"\",\n    role: \"assistant\"\n  };\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    streamedResponse += decode(value);\n    const functionStart = streamedResponse.indexOf(\"{\");\n    if (functionStart !== -1) {\n      const matches = /(.*?)(?:({\"function_call\".*?}})(.*))?$/gs.exec(\n        streamedResponse\n      );\n      responseMessage.content = `${(_c = matches == null ? void 0 : matches[1]) != null ? _c : \"\"}${(_d = matches == null ? void 0 : matches[3]) != null ? _d : \"\"}`;\n      responseMessage.function_call = matches == null ? void 0 : matches[2];\n    } else {\n      responseMessage.content = streamedResponse;\n    }\n    mutate([...chatRequest.messages, { ...responseMessage }]);\n    if (abortControllerRef === null) {\n      reader.cancel();\n      break;\n    }\n  }\n  if (typeof responseMessage.function_call === \"string\") {\n    const parsedFunctionCall = JSON.parse(responseMessage.function_call).function_call;\n    responseMessage.function_call = parsedFunctionCall;\n    mutate([...chatRequest.messages, { ...responseMessage }]);\n  }\n  if (onFinish) {\n    onFinish(responseMessage);\n  }\n  return responseMessage;\n};\nvar uniqueId = 0;\nvar store = {};\nfunction useChat({\n  api = \"/api/chat\",\n  id,\n  initialMessages = [],\n  initialInput = \"\",\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body\n} = {}) {\n  const chatId = id || `chat-${uniqueId++}`;\n  const key = `${api}|${chatId}`;\n  const {\n    data,\n    mutate: originalMutate,\n    isLoading: isSWRLoading\n  } = F2(key, {\n    fetcher: () => store[key] || initialMessages,\n    fallbackData: initialMessages\n  });\n  const loading = writable(false);\n  data.set(initialMessages);\n  const mutate = (data2) => {\n    store[key] = data2;\n    return originalMutate(data2);\n  };\n  const messages = data;\n  let abortController = null;\n  const extraMetadata = {\n    credentials,\n    headers,\n    body\n  };\n  const error = writable(void 0);\n  async function triggerRequest(chatRequest) {\n    try {\n      loading.set(true);\n      abortController = new AbortController();\n      while (true) {\n        const streamedResponseMessage = await getStreamedResponse(\n          api,\n          chatRequest,\n          mutate,\n          extraMetadata,\n          get(messages),\n          abortController,\n          onFinish,\n          onResponse,\n          sendExtraMessageFields\n        );\n        if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n          break;\n        }\n        if (experimental_onFunctionCall) {\n          const functionCall = streamedResponseMessage.function_call;\n          const functionCallResponse = await experimental_onFunctionCall(get(messages), functionCall);\n          if (functionCallResponse === void 0)\n            break;\n          chatRequest = functionCallResponse;\n        }\n      }\n      abortController = null;\n      return null;\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        abortController = null;\n        return null;\n      }\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n      error.set(err);\n    } finally {\n      loading.set(false);\n    }\n  }\n  const append = async (message, { options, functions, function_call } = {}) => {\n    if (!message.id) {\n      message.id = nanoid();\n    }\n    const chatRequest = {\n      messages: get(messages).concat(message),\n      options,\n      ...functions !== void 0 && { functions },\n      ...function_call !== void 0 && { function_call }\n    };\n    return triggerRequest(chatRequest);\n  };\n  const reload = async ({\n    options,\n    functions,\n    function_call\n  } = {}) => {\n    const messagesSnapshot = get(messages);\n    if (messagesSnapshot.length === 0)\n      return null;\n    const lastMessage = messagesSnapshot.at(-1);\n    if ((lastMessage == null ? void 0 : lastMessage.role) === \"assistant\") {\n      const chatRequest2 = {\n        messages: messagesSnapshot.slice(0, -1),\n        options,\n        ...functions !== void 0 && { functions },\n        ...function_call !== void 0 && { function_call }\n      };\n      return triggerRequest(chatRequest2);\n    }\n    const chatRequest = {\n      messages: messagesSnapshot,\n      options,\n      ...functions !== void 0 && { functions },\n      ...function_call !== void 0 && { function_call }\n    };\n    return triggerRequest(chatRequest);\n  };\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n  const setMessages = (messages2) => {\n    mutate(messages2);\n  };\n  const input = writable(initialInput);\n  const handleSubmit = (e, options = {}) => {\n    e.preventDefault();\n    const inputValue = get(input);\n    if (!inputValue)\n      return;\n    append(\n      {\n        content: inputValue,\n        role: \"user\",\n        createdAt: /* @__PURE__ */ new Date()\n      },\n      options\n    );\n    input.set(\"\");\n  };\n  return {\n    messages,\n    error,\n    append,\n    reload,\n    stop,\n    setMessages,\n    input,\n    handleSubmit,\n    isLoading: isSWRLoading || loading\n  };\n}\n\n// svelte/use-completion.ts\nimport { get as get2, writable as writable2 } from \"svelte/store\";\nvar uniqueId2 = 0;\nvar store2 = {};\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  onResponse,\n  onFinish,\n  onError\n} = {}) {\n  const completionId = id || `completion-${uniqueId2++}`;\n  const key = `${api}|${completionId}`;\n  const {\n    data,\n    mutate: originalMutate,\n    isLoading: isSWRLoading\n  } = F2(key, {\n    fetcher: () => store2[key] || initialCompletion,\n    fallbackData: initialCompletion\n  });\n  const loading = writable2(false);\n  data.set(initialCompletion);\n  const mutate = (data2) => {\n    store2[key] = data2;\n    return originalMutate(data2);\n  };\n  const completion = data;\n  const error = writable2(void 0);\n  let abortController = null;\n  async function triggerRequest(prompt, options) {\n    try {\n      loading.set(true);\n      abortController = new AbortController();\n      mutate(\"\");\n      const res = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n          prompt,\n          ...body,\n          ...options == null ? void 0 : options.body\n        }),\n        headers: {\n          ...headers,\n          ...options == null ? void 0 : options.headers\n        },\n        signal: abortController.signal,\n        credentials\n      }).catch((err) => {\n        throw err;\n      });\n      if (onResponse) {\n        try {\n          await onResponse(res);\n        } catch (err) {\n          throw err;\n        }\n      }\n      if (!res.ok) {\n        throw new Error(\n          await res.text() || \"Failed to fetch the chat response.\"\n        );\n      }\n      if (!res.body) {\n        throw new Error(\"The response body is empty.\");\n      }\n      let result = \"\";\n      const reader = res.body.getReader();\n      const decoder = createChunkDecoder();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        result += decoder(value);\n        mutate(result);\n        if (abortController === null) {\n          reader.cancel();\n          break;\n        }\n      }\n      if (onFinish) {\n        onFinish(prompt, result);\n      }\n      abortController = null;\n      return result;\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        abortController = null;\n        return null;\n      }\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n      error.set(err);\n    } finally {\n      loading.set(false);\n    }\n  }\n  const complete = async (prompt, options) => {\n    return triggerRequest(prompt, options);\n  };\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n  const setCompletion = (completion2) => {\n    mutate(completion2);\n  };\n  const input = writable2(initialInput);\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const inputValue = get2(input);\n    if (!inputValue)\n      return;\n    return complete(inputValue);\n  };\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    handleSubmit,\n    isLoading: isSWRLoading || loading\n  };\n}\nexport {\n  useChat,\n  useCompletion\n};\n","<script lang=\"ts\">\n  import { useCompletion } from 'ai/svelte';\n  import { Popover } from 'carbon-components-svelte';\n  import type { PopoverProps } from 'carbon-components-svelte/types/Popover/Popover.svelte';\n  import MagicWandFilled from 'carbon-icons-svelte/lib/MagicWandFilled.svelte';\n  import IconButton from '$lib/components/IconButton/index.svelte';\n  import { Loading } from 'carbon-components-svelte';\n  import HtmlRender from '$lib/components/HTMLRender/HTMLRender.svelte';\n  import { t } from '$lib/utils/functions/translations';\n\n  export let className = '';\n  export let handleInsert = (v: string) => {};\n  export let defaultPrompt = '';\n  export let alignPopover: PopoverProps['align'] = 'left';\n  export let isHTML = false;\n\n  let openPopover = false;\n  let plainText = '';\n  let textRef: HTMLParagraphElement;\n  let prompt: string = defaultPrompt;\n\n  let isSubmitted = false;\n\n  const { input, handleSubmit, completion, isLoading } = useCompletion({\n    api: '/api/completion/customprompt'\n  });\n\n  function restart() {\n    isSubmitted = false;\n    plainText = '';\n  }\n\n  function onCompletion(completion: string) {\n    plainText = completion;\n    if (textRef) {\n      textRef.scrollTop = textRef.scrollHeight;\n    }\n  }\n\n  function callAI(prompt: string, rephrase: boolean) {\n    isSubmitted = true;\n\n    $input = rephrase ? `${$t('ai.can_you')}: ${plainText}` : prompt;\n\n    setTimeout(() => {\n      handleSubmit({ preventDefault: () => {} });\n    }, 500);\n  }\n\n  $: onCompletion($completion);\n  $: prompt = defaultPrompt;\n</script>\n\n<div class=\"{className} relative z-[100]\">\n  <IconButton\n    contained={true}\n    color=\"text-primary-700 dark:bg-neutral-500 dark:text-white\"\n    size=\"large\"\n    onClick={() => (openPopover = !openPopover)}\n  >\n    <MagicWandFilled size={16} class=\"carbon-icon\" />\n    <Popover caret align={alignPopover} bind:open={openPopover}>\n      <button\n        class=\"p-2 w-[300px] h-[220px] text-start\"\n        type=\"button\"\n        on:click={(e) => e.stopPropagation()}\n      >\n        {#if isSubmitted}\n          <div class=\"h-[200px]\">\n            <div\n              bind:this={textRef}\n              class=\"h-[82%] bg-white dark:bg-neutral-700 p-2 overflow-y-auto text-sm text-start w-full my-1\"\n            >\n              {#if isHTML}\n                <HtmlRender content={plainText} />\n              {:else}\n                <p class=\"font-normal\">\n                  {plainText}\n                </p>\n              {/if}\n            </div>\n            <div class=\"flex gap-5 ml-2\">\n              <button\n                class=\"text-xs px-4 py-2 border-[1px] cursor-pointer rounded-md font-medium\"\n                on:click={() => {\n                  handleInsert(plainText);\n                  openPopover = false;\n                }}\n                type=\"button\"\n                disabled={$isLoading}\n              >\n                {#if $isLoading}\n                  <Loading withOverlay={false} small />\n                {:else}\n                  {$t('ai.insert')}\n                {/if}\n              </button>\n              <button\n                class=\"text-xs px-4 py-2 border-[1px] cursor-pointer rounded-md font-medium {$isLoading &&\n                  'opacity-25 cursor-not-allowed'}\"\n                on:click|preventDefault={() => callAI(prompt, true)}\n                type=\"button\"\n                disabled={$isLoading}\n              >\n                {$t('ai.rephrase')}\n              </button>\n              {#if !$isLoading}\n                <button\n                  class=\"text-xs px-4 py-2 border-[1px] cursor-pointer rounded-md font-medium\"\n                  on:click|preventDefault={restart}\n                  type=\"button\"\n                >\n                  {$t('ai.reset')}\n                </button>\n              {/if}\n            </div>\n          </div>\n        {:else}\n          <div class=\"h-full\">\n            <p class=\"text-sm font-medium mb-2 ml-1\">{$t('ai.help_me')}</p>\n            <textarea\n              bind:value={prompt}\n              class=\"w-full border-0 rounded-lg h-[65%] text-sm m-0 dark:text-black\"\n              placeholder={$t('ai.placeholder')}\n            />\n            <button\n              class=\"flex text-xs px-4 py-2 m-0 border rounded-md font-medium\"\n              on:click|preventDefault={() => callAI(prompt, false)}\n              type=\"button\"\n            >\n              {$t('ai.text')}\n            </button>\n          </div>\n        {/if}\n      </button>\n    </Popover>\n  </IconButton>\n</div>\n","<script lang=\"ts\">\n  import CustomPromptBtn from '$lib/components/AI/AIButton/CustomPromptBtn.svelte';\n  import type { PopoverProps } from 'carbon-components-svelte/types/Popover/Popover.svelte';\n  import { t } from '$lib/utils/functions/translations';\n\n  export let label = '';\n  export let disabled = false;\n  export let placeholder = $t('course.navItem.lessons.exercises.all_exercises.write_your_answer');\n  export let value = '';\n  export let rows = 3;\n  // export let maxRows = 3;\n  export let className = '';\n  export let labelClassName = '';\n  export let bgColor = 'bg-gray-50 focus:bg-primary-50 dark:bg-neutral-700 dark:text-white';\n  export let helperMessage = '';\n  export let errorMessage = '';\n  export let isRequired = false;\n  export let onChange = () => {}; // This is to know if element is 'dirty'\n  export let ref = null;\n  export let isAIEnabled = false;\n  export let initAIPrompt = '';\n  export let aiAlignPopover: PopoverProps['align'] = 'left';\n\n  // $: minHeight = `${1 + parseInt(rows, 10) * 1.2}em`;\n  // $: maxHeight = maxRows ? `${1 + maxRows * 1.2}em` : `auto`;\n</script>\n\n<label for=\"text-field\" class=\"block w-full relative {className}\">\n  {#if label}\n    <p class=\"dark:text-white text-left w-full flex items-center justify-between {labelClassName}\">\n      <span>\n        {label}\n        {#if isRequired}\n          <span class=\"text-red-700\">*</span>\n        {/if}\n      </span>\n\n      {#if isAIEnabled}\n        <CustomPromptBtn\n          bind:defaultPrompt={initAIPrompt}\n          alignPopover={aiAlignPopover}\n          handleInsert={(v) => {\n            value = v;\n          }}\n        />\n      {/if}\n    </p>\n  {/if}\n\n  <!-- <pre\n    aria-hidden=\"true\"\n    style=\"min-height: {minHeight}; max-height: {maxHeight}\">\n    {value + '\\n'}\n  </pre> -->\n\n  <textarea\n    {disabled}\n    {rows}\n    {placeholder}\n    bind:value\n    bind:this={ref}\n    required={isRequired}\n    class=\"form-textarea border-l-0 border-r-0 border-t-0 border-b-2 border-gray-200 dark:border-neutral-600 focus:border-l-0 focus:border-r-0 rounded-t-md focus:border-t-0 focus:border-b-2 focus:border-primary-600 mt-1 block w-full\n    {bgColor} {!!errorMessage ? 'border-red-500' : 'border-gray-300'}\"\n    on:change={onChange}\n  />\n  {#if !!errorMessage}\n    <p class=\"text-sm text-red-500\">\n      {errorMessage}\n    </p>\n  {:else if helperMessage}\n    <p class=\"text-sm text-gray-500 dark:text-white\">\n      {helperMessage}\n    </p>\n  {/if}\n  <slot name=\"iconbutton\" />\n</label>\n\n<style>\n  .form-textarea {\n    box-shadow: none !important;\n  }\n</style>\n"],"names":["size","$$props","title","$$invalidate","attributes","labelled","P","F","r","t","h","I","e","s","L","S","O","q","x","i","a","E","T","X","H","o","c2","l","_a","n","A2","C","R","W2","D2","d","K2","m","f","u","g","M","v2","b","p2","w2","p","D","q2","x2","K","z","v","A","y","S2","h2","O2","beforeUpdate","onDestroy","W","c","F2","createChunkDecoder","decoder","chunk","uniqueId2","store2","useCompletion","api","id","initialCompletion","initialInput","credentials","headers","body","onResponse","onFinish","onError","completionId","key","data","originalMutate","isSWRLoading","loading","writable","mutate","data2","completion","error","abortController","triggerRequest","prompt","options","res","err","result","reader","done","value","complete","stop","setCompletion","completion2","input","inputValue","get_store_value","t0_value","ctx","t3_value","attr","textarea","textarea_placeholder_value","dirty","set_data","t0","t3","t2_value","button1","button1_class_value","current","t2","t_1_value","t_1","textRef","handleSubmit","isLoading","restart","callAI","prompt2","rephrase","set_store_value","$input","$t","plainText","handleInsert","openPopover","func","onCompletion","$completion","defaultPrompt","textarea_class_value","is_function","placeholder","onChange"],"mappings":"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","x_google_ignoreList":[0,1]}