{"version":3,"file":"index.523fac41.js","sources":["../../../../../../src/lib/utils/functions/isUUID.ts","../../../../../../src/lib/components/Question/constants.ts","../../../../../../src/lib/utils/constants/course.ts","../../../../../../src/lib/utils/services/courses/index.ts"],"sourcesContent":["export function isUUID(uuid: string) {\n  let s = '' + uuid;\n\n  const m: RegExpMatchArray | null = s.match(\n    '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'\n  );\n\n  if (m === null) {\n    return false;\n  }\n\n  return true;\n}\n","export const QUESTION_TYPE = {\n  RADIO: 1,\n  CHECKBOX: 2,\n  TEXTAREA: 3\n};\n\nexport const QUESTION_TYPES = [\n  {\n    id: QUESTION_TYPE.RADIO,\n    label: 'course.navItem.lessons.exercises.all_exercises.edit_mode.question_types.single'\n  },\n  {\n    id: QUESTION_TYPE.CHECKBOX,\n    label: 'course.navItem.lessons.exercises.all_exercises.edit_mode.question_types.multiple'\n  },\n  {\n    id: QUESTION_TYPE.TEXTAREA,\n    label: 'course.navItem.lessons.exercises.all_exercises.edit_mode.question_types.paragraph'\n  }\n];\n\nexport const QUESTION_TEMPLATE = {\n  id: 1,\n  title: '',\n  type: QUESTION_TYPE.RADIO,\n  answers: [],\n  options: [\n    {\n      id: 1,\n      value: null\n    }\n  ]\n};\n","export enum STATUS {\n  ACTIVE,\n  ARCHIVE,\n  DELETED\n}\n","import { get } from 'svelte/store';\nimport { supabase } from '$lib/utils/functions/supabase';\nimport { isUUID } from '$lib/utils/functions/isUUID';\nimport { QUESTION_TYPE } from '$lib/components/Question/constants';\nimport type {\n  Lesson,\n  Course,\n  Group,\n  Groupmember,\n  Exercise,\n  LessonCompletion,\n  ExerciseTemplate,\n  LessonSection\n} from '$lib/utils/types';\nimport { STATUS } from '$lib/utils/constants/course';\nimport type { PostgrestSingleResponse, PostgrestError } from '@supabase/supabase-js';\nimport type { ProfileCourseProgress } from '$lib/utils/types';\nimport { isOrgAdmin } from '$lib/utils/store/org';\n\nexport async function fetchCourses(profileId, orgId) {\n  if (!orgId || !profileId) return;\n\n  const match = {};\n  // Filter by profile_id if role isn't admin within organization\n  if (!get(isOrgAdmin)) {\n    match.member_profile_id = profileId;\n  }\n\n  // Gets courses for a particular organisation where the current logged in user is a groupmember\n  const { data: allCourses } = await supabase\n    .rpc('get_courses', {\n      org_id_arg: orgId,\n      profile_id_arg: profileId\n    })\n    .match(match);\n\n  console.log(`allCourses`, allCourses);\n  if (!Array.isArray(allCourses)) {\n    return {\n      allCourses: []\n    };\n  }\n\n  return { allCourses };\n}\n\nexport async function fetchProfileCourseProgress(\n  courseId,\n  profileId\n): Promise<{\n  data: ProfileCourseProgress[] | null;\n  error: PostgrestError | null;\n}> {\n  const { data, error } = await supabase\n    .rpc('get_course_progress', {\n      course_id_arg: courseId,\n      profile_id_arg: profileId\n    })\n    .returns<ProfileCourseProgress[]>();\n\n  return { data, error };\n}\n\nconst SLUG_QUERY = `\n  id,\n  title,\n  type,\n  description,\n  overview,\n  logo,\n  is_published,\n  slug,\n  cost,\n  version,\n  currency,\n  metadata,\n  is_certificate_downloadable,\n  certificate_theme,\n  lesson_section(id, title, order),\n  lessons:lesson(\n    id, title, order, section_id\n  )\n`;\n\nconst ID_QUERY = `\n  id,\n  title,\n  type,\n  description,\n  overview,\n  logo,\n  is_published,\n  version,\n  group(*,\n    members:groupmember(*,\n      profile(*)\n    )\n  ),\n  slug,\n  cost,\n  currency,\n  metadata,\n  is_certificate_downloadable,\n  certificate_theme,\n  lesson_section(id, title, order, created_at),\n  lessons:lesson(\n    id, title, public, lesson_at, is_unlocked, order, created_at, section_id,\n    note, videos, slide_url, call_url, totalExercises:exercise(count), totalComments:lesson_comment(count),\n    profile:teacher_id(id, avatar_url, fullname),\n    lesson_completion(id, profile_id, is_complete)\n  ),\n  attendance:group_attendance(*),\n  polls:apps_poll(status)\n`;\n\nexport async function fetchCourse(courseId?: Course['id'], slug?: Course['slug']) {\n  const match: { slug?: string; id?: string; status?: string } = {};\n\n  if (slug) {\n    match.slug = slug;\n  } else {\n    match.id = courseId;\n  }\n\n  match.status = STATUS[STATUS.ACTIVE];\n\n  const response: PostgrestSingleResponse<Course | null> = await supabase\n    .from('course')\n    .select(slug ? SLUG_QUERY : ID_QUERY)\n    .match(match)\n    .single();\n\n  const { data, error } = response;\n\n  console.log(`error`, error);\n  console.log(`data`, data);\n  if (!data || error) {\n    console.log(`data`, data);\n    console.log(`fetchCourse => error`, error);\n    // return this.redirect(307, '/courses');\n    return { data, error };\n  }\n\n  return {\n    data,\n    error\n  };\n}\n\nexport async function fetchExploreCourses(profileId, orgId) {\n  if (!orgId || !profileId) return;\n\n  const { data: allCourses } = await supabase.rpc('get_explore_courses', {\n    org_id_arg: orgId,\n    profile_id_arg: profileId\n  });\n\n  if (!Array.isArray(allCourses)) {\n    return {\n      allCourses: []\n    };\n  }\n\n  return { allCourses };\n}\n\nexport async function fetchGroup(groupId: Group['id']) {\n  const { data, error } = await supabase\n    .from('group')\n    .select(`*,members:groupmember(*,profile(*))`)\n    .match({ id: groupId })\n    .single();\n\n  return {\n    data,\n    error\n  };\n}\n\nexport async function uploadAvatar(courseId: string, avatar: string) {\n  const filename = `course/${courseId + Date.now()}.webp`;\n  let logo;\n\n  const { data } = await supabase.storage.from('avatars').upload(filename, avatar, {\n    cacheControl: '3600',\n    upsert: false\n  });\n\n  if (data) {\n    const { data } = supabase.storage.from('avatars').getPublicUrl(filename);\n\n    if (!data.publicUrl) return;\n\n    logo = data.publicUrl;\n  }\n\n  return logo;\n}\n\nexport async function updateCourse(\n  courseId: Course['id'],\n  avatar: string | undefined,\n  course: Partial<Course>\n) {\n  if (avatar && courseId) {\n    const filename = `course/${courseId + Date.now()}.webp`;\n\n    const { data } = await supabase.storage.from('avatars').upload(filename, avatar, {\n      cacheControl: '3600',\n      upsert: false\n    });\n\n    if (data) {\n      const { data: response } = supabase.storage.from('avatars').getPublicUrl(filename);\n\n      if (!response.publicUrl) return;\n\n      course.logo = response.publicUrl;\n    }\n  }\n\n  await supabase.from('course').update(course).match({ id: courseId });\n\n  return course.logo;\n}\n\nexport async function deleteCourse(courseId: Course['id']) {\n  return await supabase.from('course').update({ status: 'DELETED' }).match({ id: courseId });\n}\n\nexport function addGroupMember(member: any) {\n  return supabase.from('groupmember').insert(member).select();\n}\n\nexport function addDefaultNewsFeed(feed) {\n  return supabase.from('course_newsfeed').insert(feed);\n}\n\nexport function updatedGroupMember(update: any, match: any) {\n  return supabase.from('groupmember').update(update).match(match);\n}\n\nexport function deleteGroupMember(groupMemberId: Groupmember['id']) {\n  return supabase.from('groupmember').delete().match({ id: groupMemberId });\n}\n\nexport function fetchLesson(lessonId: Lesson['id']) {\n  return supabase\n    .from('lesson')\n    .select(\n      `id,\n      title,\n      note,\n      videos,\n      slide_url,\n      call_url,\n      totalExercises:exercise(count),\n      totalComments:lesson_comment(count),\n      lesson_completion(id, profile_id, is_complete),\n      lesson_language(id, content, locale)\n    `\n    )\n    .eq('id', lessonId)\n    .single();\n}\n\nexport function fetchLesssonLanguageHistory(lessonId: string, locale: string, endRange: number) {\n  return supabase\n    .from('lesson_versions')\n    .select('*')\n    .range(0, endRange)\n    .eq('lesson_id', lessonId)\n    .eq('locale', locale)\n    .order('timestamp', { ascending: false });\n}\n\nexport function createLesson(lesson: any) {\n  return supabase.from('lesson').insert(lesson).select();\n}\nexport function createLessonSection(section: any) {\n  return supabase.from('lesson_section').insert(section).select();\n}\nexport function updateLessonSection(section: any, sectionId: LessonSection['id']) {\n  return supabase\n    .from('lesson_section')\n    .update({ ...section, id: undefined })\n    .match({ id: sectionId });\n}\n\nexport async function updateLesson(lesson: any, lessonId: Lesson['id']) {\n  return supabase\n    .from('lesson')\n    .update({ ...lesson, id: undefined })\n    .match({ id: lessonId });\n}\n\nexport function updateLessonCompletion(completion: LessonCompletion, shouldUpdate: boolean) {\n  if (shouldUpdate) {\n    return supabase\n      .from('lesson_completion')\n      .update({\n        is_complete: completion.is_complete\n      })\n      .eq('id', completion.id);\n  } else {\n    return supabase.from('lesson_completion').insert(completion);\n  }\n}\n\nexport const upsertLessons = (data: { id: string; order: number }[]) => {\n  return supabase.from('lesson').upsert(data);\n};\n\nexport const upsertLessonSections = (data: { id: string; order: number }[]) => {\n  return supabase.from('lesson_section').upsert(data);\n};\n\nexport function deleteLesson(lessonId: Lesson['id']) {\n  // Need to implement soft delete\n  return supabase.from('lesson').delete().match({ id: lessonId });\n}\n\nexport function deleteLessonSection(id: LessonSection['id']) {\n  // Need to implement soft delete\n  return supabase.from('lesson_section').delete().match({ id });\n}\n\nexport function createExercise(exercise: any) {\n  return supabase.from('exercise').insert(exercise).select();\n}\n\nexport function fetchExercisesByMarks(courseId: Course['id']) {\n  return supabase.rpc('get_exercises').eq('course_id', courseId);\n}\n\nfunction isNew(item: any) {\n  return isNaN(item);\n}\n\nexport async function createExerciseFromTemplate(\n  lessonId: string,\n  template: ExerciseTemplate\n): Promise<any | undefined> {\n  const { data, error } = await createExercise({\n    title: template.title,\n    description: template.description,\n    lesson_id: lessonId\n  });\n\n  if (error) {\n    console.error('Something went wrong', error);\n    return;\n  }\n\n  const { id } = data[0] || {};\n  if (!id) {\n    console.error('Something went wrong, no id', error);\n    return;\n  }\n\n  await upsertExercise(template.questionnaire, id);\n\n  return data[0];\n}\n\nexport async function upsertExercise(questionnaire: any, exerciseId: Exercise['id']) {\n  const {\n    questions,\n    title,\n    description,\n    due_by,\n    is_title_dirty,\n    is_description_dirty,\n    is_due_by_dirty\n  } = questionnaire;\n\n  if (is_description_dirty || is_title_dirty || is_due_by_dirty) {\n    await supabase\n      .from('exercise')\n      .update({\n        title,\n        description,\n        due_by\n      })\n      .match({ id: exerciseId });\n  }\n\n  const updatedQuestions = [];\n\n  for (const question of questions) {\n    const { title, id, name, question_type, options, deleted_at, order, points, is_dirty } =\n      question;\n\n    // \"DELETE\" /delete/:questionId - Don't delete if answer already given\n    if (deleted_at) {\n      // Delete from server only if this question exists in the database\n      if (!isNew(id)) {\n        await supabase.from('option').delete().match({ question_id: id });\n        await supabase.from('question_answer').delete().match({ question_id: id });\n        const { error } = await supabase.from('question').delete().match({ id });\n\n        if (error) {\n          console.error('Cannot delete this question', error);\n          continue;\n        }\n      }\n\n      // Skip the remaining operation so we filter out this question from the new questions array\n      continue;\n    }\n\n    // \"INSERT\" or \"UPDATE\" /update/:questionId or /insert/:questionId\n    const newQuestion = {\n      id: isNew(id) ? undefined : id,\n      name: isNew(id) ? undefined : name,\n      title,\n      points,\n      order,\n      question_type_id: question_type.id,\n      exercise_id: exerciseId\n    };\n    let questionSupabaseRes;\n\n    if (is_dirty || isNew(id)) {\n      const res = await supabase.from('question').upsert(newQuestion).select();\n\n      if (res.error) {\n        console.error(`Upsert question`, res.error);\n      }\n      questionSupabaseRes = Array.isArray(res.data) ? res.data[0] : null;\n    } else {\n      questionSupabaseRes = Object.assign(newQuestion);\n    }\n\n    if (questionSupabaseRes) {\n      const { question_type_id, id, name, order } = questionSupabaseRes;\n\n      // Delete cause this is not a field in the table\n      delete newQuestion.question_type_id;\n\n      // @ts-ignore\n      newQuestion.question_type = { id: question_type_id, label: question_type.label || '' };\n      newQuestion.id = id;\n      newQuestion.name = name;\n      newQuestion.order = order;\n      // @ts-ignore\n      newQuestion.options = [];\n\n      // Don't map options for 'Paragraph' questions\n      if (QUESTION_TYPE.TEXTAREA !== question_type_id) {\n        for (const option of options) {\n          const { deleted_at, is_dirty } = option;\n\n          // \"DELETE\" /delete/:optionId\n          if (deleted_at) {\n            // if this option exists in the database\n            if (!isNew(option.id)) {\n              supabase.from('option').delete().match({ id: option.id });\n            }\n\n            // Skip the remaining operation so we filter out this option from the new option array\n            continue;\n          }\n\n          // \"INSERT\" and \"UPDATE\"\n          const newOption = {\n            ...option,\n            is_dirty: undefined,\n            id: isNew(option.id) ? undefined : option.id,\n            value: isUUID(option.value) ? option.value : undefined, // this value is of UUID type\n            question_id: newQuestion.id\n          };\n\n          if (is_dirty || isNew(option.id)) {\n            const { data } = await supabase.from('option').upsert(newOption).select();\n            if (Array.isArray(data)) {\n              // @ts-ignore\n              newQuestion.options.push(data[0]);\n            }\n          } else {\n            // @ts-ignore\n            newQuestion.options.push(newOption);\n          }\n        }\n      }\n\n      updatedQuestions.push(newQuestion);\n    }\n  }\n\n  return updatedQuestions;\n}\n\ninterface LooseObject {\n  [key: string]: any;\n}\n\nexport async function submitExercise(\n  answers: Array<string>,\n  questions: Array<{ name: string; id: string }>,\n  exerciseId: Exercise['id'],\n  courseId: Course['id'],\n  groupMemberId: Groupmember['id'] | undefined\n) {\n  if (!groupMemberId) {\n    return;\n  }\n\n  const questionsByName = questions.reduce(\n    (acc, q) => ({ ...acc, [q.name]: q.id }),\n    {}\n  ) as LooseObject;\n  const questionAnswers = [];\n\n  const { data: submission } = await supabase\n    .from('submission')\n    .insert({\n      submitted_by: groupMemberId,\n      exercise_id: exerciseId,\n      course_id: courseId\n    })\n    .select();\n\n  for (const questionName in answers) {\n    const value = answers[questionName];\n\n    const questionAnswer = {\n      group_member_id: groupMemberId,\n      question_id: questionsByName[questionName],\n      open_answer: '',\n      answers: [],\n      submission_id: Array.isArray(submission) ? submission[0].id : null\n    };\n\n    if (typeof value === 'string') {\n      questionAnswer.open_answer = value;\n    } else {\n      questionAnswer.answers = value;\n    }\n\n    questionAnswers.push(questionAnswer);\n  }\n\n  const res = await supabase.from('question_answer').insert(questionAnswers).select();\n  console.log(`res`, res, 'submission', submission);\n  return {\n    submission,\n    res\n  };\n}\n\nexport async function deleteExercise(questions: Array<{ id: string }>, exerciseId: Exercise['id']) {\n  for (const question of questions) {\n    const { id } = question;\n\n    await supabase.from('option').delete().match({ question_id: id });\n    await supabase.from('question_answer').delete().match({ question_id: id });\n\n    await supabase.from('question').delete().match({ id });\n  }\n\n  await supabase.from('submission').delete().match({ exercise_id: exerciseId });\n  await supabase.from('exercise').delete().match({ id: exerciseId });\n}\n"],"names":["isUUID","uuid","QUESTION_TYPE","QUESTION_TYPES","QUESTION_TEMPLATE","STATUS","STATUS2","fetchCourses","profileId","orgId","match","get_store_value","isOrgAdmin","allCourses","supabase","fetchProfileCourseProgress","courseId","data","error","SLUG_QUERY","ID_QUERY","fetchCourse","slug","response","fetchExploreCourses","fetchGroup","groupId","uploadAvatar","avatar","filename","logo","data2","updateCourse","course","deleteCourse","addGroupMember","member","addDefaultNewsFeed","feed","deleteGroupMember","groupMemberId","fetchLesson","lessonId","fetchLesssonLanguageHistory","locale","endRange","createLesson","lesson","createLessonSection","section","updateLessonSection","sectionId","updateLesson","updateLessonCompletion","completion","shouldUpdate","deleteLesson","deleteLessonSection","id","createExercise","exercise","fetchExercisesByMarks","isNew","item","createExerciseFromTemplate","template","upsertExercise","questionnaire","exerciseId","questions","title","description","due_by","is_title_dirty","is_description_dirty","is_due_by_dirty","updatedQuestions","question","title2","name","question_type","options","deleted_at","order","points","is_dirty","newQuestion","questionSupabaseRes","res","question_type_id","id2","name2","order2","option","deleted_at2","is_dirty2","newOption","submitExercise","answers","questionsByName","acc","q","questionAnswers","submission","questionName","value","questionAnswer","deleteExercise"],"mappings":"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"}