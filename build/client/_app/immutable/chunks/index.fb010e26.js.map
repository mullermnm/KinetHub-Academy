{"version":3,"file":"index.fb010e26.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@4.1.2/node_modules/svelte/src/runtime/internal/animations.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/dispatcher.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/constants.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/intersection.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/listUtil.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/scroller.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/util.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/observer.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/windowScroller.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/styler.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/pointerAction.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/helpers/aria.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/keyboardAction.js","../../../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.24_svelte@4.1.2/node_modules/svelte-dnd-action/src/action.js","../../../../../../../../node_modules/.pnpm/svelte@4.1.2/node_modules/svelte/src/runtime/animate/index.js"],"sourcesContent":["import { identity as linear, noop } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} from\n * @param {import('./private.js').AnimationFn} fn\n */\nexport function create_animation(node, from, fn, params) {\n\tif (!from) return noop;\n\tconst to = node.getBoundingClientRect();\n\tif (\n\t\tfrom.left === to.left &&\n\t\tfrom.right === to.right &&\n\t\tfrom.top === to.top &&\n\t\tfrom.bottom === to.bottom\n\t)\n\t\treturn noop;\n\tconst {\n\t\tdelay = 0,\n\t\tduration = 300,\n\t\teasing = linear,\n\t\t// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n\t\tstart: start_time = now() + delay,\n\t\t// @ts-ignore todo:\n\t\tend = start_time + duration,\n\t\ttick = noop,\n\t\tcss\n\t} = fn(node, { from, to }, params);\n\tlet running = true;\n\tlet started = false;\n\tlet name;\n\t/** @returns {void} */\n\tfunction start() {\n\t\tif (css) {\n\t\t\tname = create_rule(node, 0, 1, duration, delay, easing, css);\n\t\t}\n\t\tif (!delay) {\n\t\t\tstarted = true;\n\t\t}\n\t}\n\t/** @returns {void} */\n\tfunction stop() {\n\t\tif (css) delete_rule(node, name);\n\t\trunning = false;\n\t}\n\tloop((now) => {\n\t\tif (!started && now >= start_time) {\n\t\t\tstarted = true;\n\t\t}\n\t\tif (started && now >= end) {\n\t\t\ttick(1, 0);\n\t\t\tstop();\n\t\t}\n\t\tif (!running) {\n\t\t\treturn false;\n\t\t}\n\t\tif (started) {\n\t\t\tconst p = now - start_time;\n\t\t\tconst t = 0 + 1 * easing(p / duration);\n\t\t\ttick(t, 1 - t);\n\t\t}\n\t\treturn true;\n\t});\n\tstart();\n\ttick(0, 1);\n\treturn stop;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {void}\n */\nexport function fix_position(node) {\n\tconst style = getComputedStyle(node);\n\tif (style.position !== 'absolute' && style.position !== 'fixed') {\n\t\tconst { width, height } = style;\n\t\tconst a = node.getBoundingClientRect();\n\t\tnode.style.position = 'absolute';\n\t\tnode.style.width = width;\n\t\tnode.style.height = height;\n\t\tadd_transform(node, a);\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} a\n * @returns {void}\n */\nexport function add_transform(node, a) {\n\tconst b = node.getBoundingClientRect();\n\tif (a.left !== b.left || a.top !== b.top) {\n\t\tconst style = getComputedStyle(node);\n\t\tconst transform = style.transform === 'none' ? '' : style.transform;\n\t\tnode.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n\t}\n}\n","// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n","import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {Boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n","// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el) {\n    let ta;\n    const rect = el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nexport function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    const rect = getAbsoluteRect(el);\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        // TODO - figure out what is so special about right (why the rect is too big)\n        right: Math.min(rect.right, document.documentElement.clientWidth) - point.x\n    };\n}\n","import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution for a specific dropzone, should be called after the zone was scrolled\n * @param {HTMLElement} dz\n */\nexport function resetIndexesCacheForDz(dz) {\n    printDebug(() => \"resetting indexes cache for dz\");\n    dzToShadowIndexToRect.delete(dz);\n}\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n","import {calcInnerDistancesBetweenPointAndSidesOfElement} from \"./intersection\";\nconst SCROLL_ZONE_PX = 25;\n\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        if (distances === null) {\n            resetScrolling();\n            return false;\n        }\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n","/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache, resetIndexesCacheForDz} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {makeScroller} from \"./scroller\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCacheForDz(lastDropZoneFound);\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetScrolling();\n    resetIndexesCache();\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {resetIndexesCache} from \"./listUtil\";\n\nconst INTERVAL_MS = 300;\nlet mousePosition;\n\n/**\n * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners\n * // TODO - make private (remove export)\n * @param {{clientX: number, clientY: number}} e\n */\nexport function updateMousePosition(e) {\n    const c = e.touches ? e.touches[0] : e;\n    mousePosition = {x: c.clientX, y: c.clientY};\n}\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\nfunction loop() {\n    if (mousePosition) {\n        const scrolled = scrollIfNeeded(mousePosition, document.documentElement);\n        if (scrolled) resetIndexesCache();\n    }\n    next = window.setTimeout(loop, INTERVAL_MS);\n}\n\n/**\n * will start watching the mouse pointer and scroll the window if it goes next to the edges\n */\nexport function armWindowScroller() {\n    printDebug(() => \"arming window scroller\");\n    window.addEventListener(\"mousemove\", updateMousePosition);\n    window.addEventListener(\"touchmove\", updateMousePosition);\n    loop();\n}\n\n/**\n * will stop watching the mouse pointer and won't scroll the window anymore\n */\nexport function disarmWindowScroller() {\n    printDebug(() => \"disarming window scroller\");\n    window.removeEventListener(\"mousemove\", updateMousePosition);\n    window.removeEventListener(\"touchmove\", updateMousePosition);\n    mousePosition = undefined;\n    window.clearTimeout(next);\n    resetScrolling();\n}\n","/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n * \n * @param {HTMLElement} el \n * @returns \n */\nexport function svelteNodeClone(el) {\n  const cloned = el.cloneNode(true);\n\n  const values = [];\n  const elIsSelect = el.tagName === \"SELECT\";\n  const selects = elIsSelect ? [el] : [...el.querySelectorAll('select')];\n  for (const select of selects) {\n    values.push(select.value);\n  }\n\n  if (selects.length <= 0) {\n    return cloned;\n  }\n\n  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll('select')];\n  for (let i = 0; i < clonedSelects.length; i++) {\n    const select = clonedSelects[i];\n    const value = values[i];\n    const optionEl = select.querySelector(`option[value=\"${value}\"`);\n    if (optionEl) {\n      optionEl.setAttribute('selected', true);\n    }\n  }\n\n  return cloned;\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        // The lines below are commented out because of issue 454 - seems like these rect values take time to update when in grid layout, therefore this gets copied from the computed styles now\n        // draggedEl.style.height = `${newRect.height}px`;\n        // draggedEl.style.width = `${newRect.width}px`;\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\" ||\n                // copying with and height to make up for rect update timing issues in some browsers\n                s === \"width\" ||\n                s === \"height\"\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {armWindowScroller, disarmWindowScroller} from \"./helpers/windowScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    armWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const observationIntervalMs = Math.max(\n        MIN_OBSERVATION_INTERVAL_MS,\n        ...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs)\n    );\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    disarmWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\n// finds the initial placeholder that is placed there on drag start\nfunction findShadowPlaceHolderIdx(items) {\n    return items.findIndex(item => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);\n}\nfunction findShadowElementIdx(items) {\n    // checking that the id is not the placeholder's for Dragula like usecases\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    } else {\n        const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);\n        if (shadowPlaceHolderIdx !== -1) {\n            // only happens right after drag start, on the first drag entered event\n            printDebug(() => \"removing placeholder item from origin dz\");\n            items.splice(shadowPlaceHolderIdx, 1);\n        }\n    }\n\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const shadowElIdx = findShadowElementIdx(items);\n    const shadowItem = items.splice(shadowElIdx, 1)[0];\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        originZoneItems.splice(originIndex, 0, shadowItem);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    items.splice(shadowElIdx, 1);\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) shadowElIdx = originIndex;\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument} */\n        const rootNode = originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items, type, centreDraggedOnCursor} = config;\n        draggedElData = {...items[currentIdx]};\n        draggedElType = type;\n        shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true};\n        // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues\n        const placeHolderElData = {...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, placeHolderElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = 0;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : 0;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = 0;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value));\n}\n","import { cubicOut } from '../easing/index.js';\nimport { is_function } from '../internal/index.js';\n\n/**\n * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.\n * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).\n *\n * https://svelte.dev/docs/svelte-animate#flip\n * @param {Element} node\n * @param {{ from: DOMRect; to: DOMRect }} fromTo\n * @param {import('./public.js').FlipParams} params\n * @returns {import('./public.js').AnimationConfig}\n */\nexport function flip(node, { from, to }, params = {}) {\n\tconst style = getComputedStyle(node);\n\tconst transform = style.transform === 'none' ? '' : style.transform;\n\tconst [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);\n\tconst dx = from.left + (from.width * ox) / to.width - (to.left + ox);\n\tconst dy = from.top + (from.height * oy) / to.height - (to.top + oy);\n\tconst { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;\n\treturn {\n\t\tdelay,\n\t\tduration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,\n\t\teasing,\n\t\tcss: (t, u) => {\n\t\t\tconst x = u * dx;\n\t\t\tconst y = u * dy;\n\t\t\tconst sx = t + (u * from.width) / to.width;\n\t\t\tconst sy = t + (u * from.height) / to.height;\n\t\t\treturn `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;\n\t\t}\n\t};\n}\n"],"names":["create_animation","node","from","fn","params","noop","to","delay","duration","easing","identity","start_time","now","end","tick","css","running","started","name","start","create_rule","stop","delete_rule","loop$1","p","t","fix_position","style","width","height","a","add_transform","b","transform","FINALIZE_EVENT_NAME","CONSIDER_EVENT_NAME","dispatchFinalizeEvent","el","items","info","dispatchConsiderEvent","DRAGGED_ENTERED_EVENT_NAME","DRAGGED_LEFT_EVENT_NAME","DRAGGED_OVER_INDEX_EVENT_NAME","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","DRAGGED_LEFT_TYPES","dispatchDraggedElementEnteredContainer","containerEl","indexObj","draggedEl","dispatchDraggedElementLeftContainerForAnother","theOtherDz","dispatchDraggedElementLeftContainerForNone","dispatchDraggedElementIsOverIndex","dispatchDraggedLeftDocument","TRIGGERS","SOURCES","SHADOW_ITEM_MARKER_PROPERTY_NAME","SHADOW_ELEMENT_ATTRIBUTE_NAME","SHADOW_PLACEHOLDER_ITEM_ID","DRAGGED_ELEMENT_ID","ITEM_ID_KEY","activeDndZoneCount","incrementActiveDropZoneCount","decrementActiveDropZoneCount","isOnServer","getBoundingRectNoTransforms","ta","rect","tx","sx","sy","dx","dy","x","y","w","h","getAbsoluteRectNoTransforms","getAbsoluteRect","findCenter","calcDistance","pointA","pointB","isPointInsideRect","point","findCenterOfElement","isCenterOfAInsideB","elA","elB","centerOfA","rectOfB","calcDistanceBetweenCenters","centerOfB","isElementOffDocument","calcInnerDistancesBetweenPointAndSidesOfElement","dzToShadowIndexToRect","resetIndexesCache","resetIndexesCacheForDz","dz","cacheShadowRect","shadowElIndex","child","findWouldBeIndex","floatingAboveEl","collectionBelowEl","children","i","cachedShadowRect","minDistanceSoFar","indexOfMin","distance","SCROLL_ZONE_PX","makeScroller","scrollingInfo","resetScrolling","scrollContainer","directionObj","stepPx","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","toString","object","getDepth","_getDepth","countSoFar","areObjectsShallowEqual","objA","objB","keyA","areArraysShallowEqualSameOrder","arrA","arrB","INTERVAL_MS$1","TOLERANCE_PX","scrollIfNeeded$1","resetScrolling$1","next$1","observe","dropZones","intervalMs","lastDropZoneFound","lastIndexFound","lastIsDraggedInADropZone","lastCentrePositionOfDragged","dropZonesFromDeepToShallow","dz1","dz2","andNow","currentCenterOfDragged","scrolled","isDraggedInADropZone","index","unobserve","INTERVAL_MS","mousePosition","updateMousePosition","c","next","loop","armWindowScroller","disarmWindowScroller","svelteNodeClone","cloned","values","elIsSelect","selects","select","clonedSelects","value","optionEl","TRANSITION_DURATION_SECONDS","trs","property","createDraggedElementFrom","originalElement","positionCenterOnXY","copyStylesFromTo","elTopPx","elLeftPx","center","moveDraggedElementToWasDroppedState","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","copyToEl","computedStyle","s","styleDraggable","draggableEl","dragDisabled","hideElement","dragTarget","decorateShadowEl","shadowEl","unDecorateShadowElement","styleActiveDropZones","getStyles","getClasses","styles","styleInactiveDropZones","preventShrinking","originalMinHeight","originalMinWidth","DEFAULT_DROP_ZONE_TYPE$1","MIN_OBSERVATION_INTERVAL_MS","MIN_MOVEMENT_BEFORE_DRAG_START_PX","DEFAULT_DROP_TARGET_STYLE$1","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","isWorkingOnPreviousDrag","finalizingPreviousDrag","unlockOriginDzMinDimensions","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","typeToDropZones$1","dzToConfig$1","elToMouseDownListener","registerDropZone$1","dropZoneEl","type","unregisterDropZone$1","watchDraggedElement","handleDraggedEntered","handleDraggedLeft","handleDraggedIsOverIndex","handleDrop$1","observationIntervalMs","unWatchDraggedElement","findShadowPlaceHolderIdx","item","findShadowElementIdx","dropFromOthersDisabled","newOriginZoneItems","shadowPlaceHolderIdx","isProximityBased","shadowElIdx","shadowItem","originZoneItems","handleMouseMove","finalizeWithinZone","cleanupPostDrop","animateDraggedToFinalPosition","callback","shadowElRect","newTransform","dropAnimationDurationMs","transition","scheduleDZForRemovalAfterDrop","destroy","dndzone$2","options","initialized","config","elToIdx","addMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","removeMaybeListeners","e","handleDragStart","handleMouseDown","currentIdx","rootNode","originDropZoneRoot","centreDraggedOnCursor","placeHolderElData","keepOriginalElementInDom","configure","newType","morphDisabled","dropTargetStyle","dropTargetClasses","transformDraggedElement","getConfigProp","propName","idx","newOptions","destroyDz","INSTRUCTION_IDs$1","ID_TO_INSTRUCTION","ALERT_DIV_ID","alertsDiv","initAriaOnBrowser","id","txt","instructionToHiddenDiv","initAria","destroyAria","_a","div","alertToScreenReader","alertText","DEFAULT_DROP_ZONE_TYPE","DEFAULT_DROP_TARGET_STYLE","isDragging","draggedItemType","focusedDz","focusedDzLabel","focusedItem","focusedItemId","focusedItemLabel","allDragTargets","elToKeyDownListeners","elToFocusListeners","dzToHandles","dzToConfig","typeToDropZones","INSTRUCTION_IDs","registerDropZone","globalKeyDownHandler","globalClickHandler","unregisterDropZone","handleDrop","handleZoneFocus","newlyFocusedDz","originItems","originItem","originIdx","itemToMove","targetItems","autoAriaDisabled","triggerAllDzsUpdate","update","dispatchConsider","dndzone$1","swap","arr","j","handleKeyDown","setCurrentFocusedItem","dropTargets","msg","handleClick","focusedItemIdx","zoneTabIndex","handles","dndzone","validateOptions","pointerZone","keyboardZone","flipDurationMs","rest","itemWithMissingId","isInt","flip","ox","oy","d","cubicOut","is_function","u"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}